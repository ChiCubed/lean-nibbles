import combinatorics.simple_graph.basic
import combinatorics.simple_graph.connectivity
import combinatorics.simple_graph.clique
import combinatorics.simple_graph.adj_matrix
import data.nat.parity
import data.nat.modeq

-- TODO modeq vs zmod

-- TODO should these be namespaced?
open simple_graph
-- so as not to have to deal with decidability nonsense
-- TODO deal with said decidability nonsense
open_locale classical

-- TODO: make relevant things "abbreviation"

namespace imo2019q3

-- this section contains all of the definitions
-- necessary for the statement of the problem.
section problem_defs

variables {V : Type*} [fintype V]

-- TODO should this be simps?
@[simps]
def bone (e : sym2 V) (h : ¬ e.is_diag) : simple_graph V :=
{adj := λ (a b : V), ⟦(a, b)⟧ = e}
-- TODO instead of having bone be simps, just have bone_adj? prior art

section move

structure move (G : simple_graph V) :=
{a b c : V}
(hab :   G.adj a b)
(hac :   G.adj a c)
(hbc : ¬ G.adj b c)
(bc_ne : b ≠ c)

variables {G : simple_graph V} (m : move G)
abbreviation move.ab := ⟦(m.a, m.b)⟧
abbreviation move.ac := ⟦(m.a, m.c)⟧
abbreviation move.bc := ⟦(m.b, m.c)⟧

-- TODO is reducible reasonable here?
@[reducible]
def move.resolve := G.delete_edges {m.ab, m.ac} ⊔ bone m.bc m.bc_ne

end move

-- TODO
@[reducible]
def exists_move (G₁ G₂ : simple_graph V) := ∃ (m : move G₁), m.resolve = G₂

def exists_move_sequence := relation.refl_trans_gen $ @exists_move V _

def is_solved_state (G : simple_graph V) := ∀ x, G.degree x ≤ 1

def exists_move_sequence_to_solved (G : simple_graph V) :=
∃ T, is_solved_state T ∧ exists_move_sequence G T

end problem_defs

section move

-- auxiliary definitions and stuff for moves,
-- separated to keep problem_defs clean

variables {V : Type*} [fintype V]

-- TODO whyyyyy are you noncomputable i hate you
-- just shove noncomputable theory at the top at this point
--
-- also should this be simp????? ????
-- FIXME this is just fucked
-- noncomputable instance move.has_coe {G : simple_graph V} {S : subgraph G} (h : S.is_induced) :
--   has_coe (move S.coe) (move G) :=
-- ⟨λ m, { hab := S.coe_adj_sub _ _ m.hab,
--         hac := S.coe_adj_sub _ _ m.hac,
--         hbc := m.hbc ∘ h (by simp : ↑m.b ∈ _) (by simp : ↑m.c ∈ _),
--         bc_ne := m.bc_ne ∘ subtype.coe_inj.mp }⟩

variables {G : simple_graph V} (m : move G)

-- TODO is simp correct here?
@[simp] lemma move.ab_ne : m.a ≠ m.b := ne_of_adj _ m.hab
@[simp] lemma move.ac_ne : m.a ≠ m.c := ne_of_adj _ m.hac
attribute [simp] move.bc_ne

@[simp] lemma move.hab' : ¬ m.resolve.adj m.a m.b := by simp
@[simp] lemma move.hac' : ¬ m.resolve.adj m.a m.c := by simp
@[simp] lemma move.hbc' :   m.resolve.adj m.b m.c := by simp

end move

section lemmata

variables {V : Type*} [fintype V]

-- NOTE TODO:
-- - preimage under quot
-- - mapping through a type
--
-- you want to identify an element of a quotient with the
-- set of things that map to it.
-- surely this is something which exists in the standard library?

-- TODO define connected component subgraphs of a graph
-- which is a subgraph generated by a connected component
--
-- TODO look into the map / comap machinery to find stuff out
-- about the connected components of a graph

-- one possible definition of a connected component:
-- define a homomorphism from G to ⊥ : simple_graph G.connected_component
-- that takes a vertex to its connected component,
-- then the preimages in this homomorphism are the connected components.

-- NOTE this is a scratchpad for trying new things yaaaaaay!

-- NOTE for now we are trying to avoid implementing new things.
-- this may bite you, so be prepared to revisit it later.
-- storyboard some ideas if you must.

-- if a move on abc is such that there is a simple cycle through ab
-- avoiding ac, the move does not disconnect the graph

-- TODO would you rather:
-- split into connected components and work on them individually?
-- or put off the connected component question for as long as possible?

-- TODO is this what you want?
open simple_graph.walk

section move_reachability

def rpl_aux {G H : simple_graph V}
  (m : ∀ u v (huv : G.adj u v), H.reachable u v) :
  ∀ {u v}, G.walk u v → H.reachable u v
| _ _ (walk.nil' u) := reachable.rfl
| _ _ (walk.cons h p) := (m _ _ h).trans (rpl_aux p)

-- if endpoints of edges in one graph are still connected in another,
-- the latter graph has at least as great reachability
lemma reachability_preservation_lemma {G H : simple_graph V}
  (m : ∀ u v (huv : G.adj u v), H.reachable u v) :
  G.reachable ≤ H.reachable :=
λ _ _ ⟨p⟩, rpl_aux m p

variable {G : simple_graph V}

-- TODO is this better phrased in terms of walks,
-- or in terms of reachability?
-- i have a sneaking suspicion that the walks are actually better...

-- TODO namespacing: i want this to be stuck in a section forever if possible.
-- like private to a section.
-- for instance, this could be in a move_connectivity section or something
lemma reach_wlog_symm {u v x y}
  (h : ⟦(u, v)⟧ = ⟦(x, y)⟧) (w : G.reachable x y) :
  G.reachable u v :=
begin
  rw sym2.eq_iff at h,
  -- TODO why is unfreezingI necessary?
  apply or.by_cases h; unfreezingI { rintro ⟨rfl, rfl⟩ },
  exact w, exact w.symm,
end

-- TODO is this necessary?
lemma move_decreases_reachability (m : move G) :
  m.resolve.reachable ≤ G.reachable :=
reachability_preservation_lemma $ λ u v huv,
  if h : ⟦(u, v)⟧ = m.bc then
    reach_wlog_symm h $ ⟨cons m.hab.symm $ cons m.hac nil⟩
  else
    suffices G.adj u v, from ⟨cons this nil⟩,
    and.elim_left $ huv.resolve_right (by simpa using h)

-- if removing ab and ac leaves a, b connected, the graph
-- remains connected after the move
-- (equiv: if there is a simple cycle through ab avoiding ac)
lemma nondisconnecting_move_lemma (m : move G)
  (p : G.walk m.a m.b) (hp : ∀ e ∈ p.edges, e ≠ m.ab ∧ e ≠ m.ac) :
  m.resolve.reachable = G.reachable :=
le_antisymm (move_decreases_reachability m) $
reachability_preservation_lemma $ λ u v huv,
  let p' : m.resolve.walk m.a m.b :=
  (p.to_delete_edges {m.ab, m.ac} (λ e he, by simp [hp e he]))
    .map (hom.map_spanning_subgraphs (by simp)) in
  if h₁ : ⟦(u, v)⟧ = m.ab then
    reach_wlog_symm h₁ $ ⟨p'⟩
  else if h₂ : ⟦(u, v)⟧ = m.ac then
    reach_wlog_symm h₂ $ ⟨p'.append $ cons (by simp) nil⟩
  else
    suffices m.resolve.adj u v, from ⟨cons this nil⟩,
    or.inl $ by simpa [h₁, h₂] using huv

end move_reachability

section cc_subgraph

variables {G : simple_graph V} (C : G.connected_component)

protected def simple_graph.subgraph.of_cc :=
(⊤ : subgraph G).induce {x | G.connected_component_mk x = C}

-- TODO the architecture of the stdlib's is_trail and is_cycle and blah stuff
-- is like, totally not correct right?
lemma cc_induced : (subgraph.of_cc C).is_induced :=
λ {v w} hv hw hvw, ⟨hv, hw, hvw⟩

variables {C}
lemma verts_trans_of_cc {x y} (hx : x ∈ (subgraph.of_cc C).verts) (hp : G.reachable x y) :
  y ∈ (subgraph.of_cc C).verts :=
begin
  simp only [subgraph.of_cc, subgraph.induce_verts, set.mem_set_of_eq] at ⊢ hx,
  simpa [← hx] using hp.symm,
end

end cc_subgraph

-- How do you stitch things together?
-- You want to make moves on induced subgraphs (connected components),
-- and prove that a move on an induced subgraph resolves nicely.
-- In particular, suppose G is presolved.
-- ↑m.resolve should be presolved iff m.resolve is presolved.
-- it suffices that reachability outside of S is unchanged, so that
-- connected components of G outside S were unchanged.
--
-- it sort of feels like enough to prove that nondisconnectingness lifts.
-- in particular, if reachability in S was unchanged, so is reachability in G.

-- -- NOTE this is cursed
-- lemma lift_nondisconnecting_move {G : simple_graph V}
--   {C : G.connected_component} (m : move (subgraph.of_cc C).coe)
--   (hm : m.resolve.reachable = (subgraph.of_cc C).coe.reachable) :
--   (by { convert ↑m,
--         haveI := move.has_coe (λ v w hv hw hvw, cc_induced C hv hw hvw : (subgraph.of_cc C).is_induced),
--         apply_instance } : move G).resolve.reachable = G.reachable :=
-- begin
--   dsimp only [eq_mpr_eq_cast, cast_eq],
--   apply le_antisymm, from move_decreases_reachability _,
--   intros u v hr,
--   have hc : G.connected_component_mk u = G.connected_component_mk v := connected_component.sound hr,
--   exact
--     if h : G.connected_component_mk u = C then
--       begin
--         have := ge_of_eq hm,
--         convert this ⟨u, h⟩ ⟨v, hc.symm.trans h⟩ _ using 0,
--         simp [reachable],
--         split; rintro ⟨w⟩,
--         sorry, -- lower walk to a cc
--         rw [move.resolve, subgraph.delete_edges_coe_eq] at w,
--         existsi (w.map (subgraph.hom _)),
--         use [map subgraph.coe w],
--       end
--     else
--       sorry
-- end

-- TODO should this be reducible? semireducible? help
def is_presolved_state (G : simple_graph V) :=
∀ C : G.connected_component, let S := subgraph.of_cc C in
  fintype.card S.verts > 2 →
  S.coe ≠ ⊤ ∧ ∃ x ∈ S.verts, odd (S.degree x)

-- TODO prior art: connected of preconnected, in the standard library?

-- TODO wlog?

-- the actual method is:
-- consider a connected component of size > 2, if any such exists.
-- if no such exists, we can prove that we are done.
-- TODO it might be useful to try consider the connected component
-- containing the smallest cycle overall.
-- otherwise:
-- if the component has a cycle:
--   we seek a nondisconnecting move.
--   TODO use the definitions provided for triangle-free graphs?
--   if the smallest such cycle is length 3:
--     consider the largest clique (size >= 3).
--     take a in the clique, c outside (c exists).
--     find b in the clique not adj to c.
--     there is an alt path b -> d -> a in the clique,
--     so that abc is a nondisconnecting move.
--   if the smallest such cycle is length > 3:
--     take a on the cycle and c off the cycle
--     such that a and c are adjacent
--     (this is possible since the component is not a cycle).
--     (proving this is possible is nontrivial.
--      use the fact that the smallest cycle is induced.)
--     pick b adjacent to a on the cycle.
--     graph is triangle free so bc is empty.
--     major arc ba implies nondisconnecting.
-- otherwise:
--   pick the move almost at random
--   move on forest produces forest (prove it!)
--   forest is always presolved

-- TODO open the finset namespace so that people who want to can use it
-- FIXME this proof needs to be made *so* many times better
lemma move_deg_parity {G : simple_graph V} (m : move G) (x : V) :
  m.resolve.degree x ≡ G.degree x [MOD 2] :=
begin
  rw nat.modeq_iff_dvd,
  simp only [move.resolve, degree, neighbor_finset_eq_filter,
    finset.card_eq_sum_ones, finset.sum_filter],
  push_cast, rw ← finset.sum_sub_distrib, norm_num1,
  dsimp only [sup_adj, delete_edges_adj, bone_adj,
    set.mem_insert_iff, set.mem_singleton_iff],

  convert_to (2 : ℤ) ∣ finset.univ.sum (λ (y : V),
    ite (⟦(x, y)⟧ = m.ab) 1 0 +
    ite (⟦(x, y)⟧ = m.ac) 1 0 -
    ite (⟦(x, y)⟧ = m.bc) 1 0) using 2,
  { funext y,

    -- TODO what's the recommended tactic to do this have_rw pattern?
    have : ite (⟦(x, y)⟧ = m.ab) 1 0 + ite (⟦(x, y)⟧ = m.ac) 1 0 =
      (ite (⟦(x, y)⟧ = m.ab ∨ ⟦(x, y)⟧ = m.ac) 1 0 : ℤ),
    { by_cases hp : ⟦(x, y)⟧ = m.ab;
      by_cases hq : ⟦(x, y)⟧ = m.ac;
      simp [hp, hq, m.bc_ne.symm] },
    rw this,

    let P := G.adj x y,
    let Q := ⟦(x, y)⟧ = m.ab ∨ ⟦(x, y)⟧ = m.ac,
    let R := ⟦(x, y)⟧ = m.bc,

    change G.adj x y with P,
    change ⟦(x, y)⟧ = m.ab ∨ ⟦(x, y)⟧ = m.ac with Q,
    change ⟦(x, y)⟧ = m.bc with R,

    have h₁ : Q → P,
    { dsimp only [P, Q], intro h,
      simp only [sym2.eq_iff] at h,
      rcases h with (⟨rfl, rfl⟩ | ⟨rfl, rfl⟩) | (⟨rfl, rfl⟩ | ⟨rfl, rfl⟩),
      from m.hab, from m.hab.symm, from m.hac, from m.hac.symm },

    have h₂ : R → ¬ P,
    { dsimp only [P, R], intro h,
      simp only [sym2.eq_iff] at h,
      rcases h with ⟨rfl, rfl⟩ | ⟨rfl, rfl⟩,
      from m.hbc, from λ h, m.hbc h.symm },

    have h₃ : R → ¬ Q,
    { dsimp only [Q, R], intro h, rw h,
      simp only [sym2.eq_iff],
      have := m.ab_ne, have := m.ac_ne, have := m.bc_ne,
      tauto },

    by_cases hr : R, { simp [hr, h₂ hr, h₃ hr] },
    by_cases hq : Q, { simp [hr, hq, h₁ hq] },
    by_cases hp : P; simp [hp, hq, hr] },

  rw [finset.sum_sub_distrib, finset.sum_add_distrib],
  norm_cast,
  simp only [← finset.sum_filter, ← finset.card_eq_sum_ones, sym2.eq_iff],

  by_cases ha : x = m.a,
  simpa [ha, finset.filter_eq' _ m.b, finset.filter_eq' _ m.c] using
    (by norm_num : (2 : ℤ) ∣ 1 + 1),
  by_cases hb : x = m.b,
  { simp [ha, hb, m.ab_ne.symm,
    finset.filter_eq' _ m.a, finset.filter_eq' _ m.c] },
  by_cases hc : x = m.c,
  { simp [ha, hb, hc, m.ac_ne.symm, m.bc_ne.symm,
    finset.filter_eq' _ m.a, finset.filter_eq' _ m.b] },
  simp [ha, hb, hc],
end

-- TODO bundled notion of a subgraph corresponding to a connected component.
-- you want to prove that:
--   - the subgraph contains everything reachable from any of its vertices
--     in the parent graph (a "transitivity property")
--   - neighbours in the subgraph = neighbours in the original graph
--     (for anything in the subgraph)
--   - degree is preserved
--     (again, for anything in the subgraph)
--   - it's an induced subgraph
--     (is this necessary for anything? like, actually?)
--
-- it should be like, actually reasonable to work with subgraphs in this form.
-- as opposed to just being like the worst thing ever.

-- TODO move correspondence lemma.
-- vaguely: move on a connected component lifts to a move that does nothing
-- to the rest of the graph.
-- rigorously: suppose a move takes a presolved connected component to another
-- presolved graph. then the move takes the entire (presolved) graph to another
-- presolved graph.
--
-- LEMMA: a graph is presolved if it is the disjoint union of two presolved graphs.
-- machinery for "disjoint union of graphs"? maybe don't worry about it?
--
-- proof strategy:
--   split the resulting graph into [subgraph corresponding to the cc the move
--     is acting on], complement.
--   the complement remains untouched → still presolved.
--     how do you prove the complement is untouched?
--     there should be a bijection between the correspnding quotient types,
--     or something sus like that.
--   the subgraph corresponding to the cc the move acted on ends up presolved,
--     by hypothesis.
--
-- if you don't want to deal with "disjoint union of graphs":
--   split the resulting graph into components.
--   components are all subcomponents of components in the original graph.
--   (more precisely: the vertex set is a subset of a component in the original graph.)
--   the coerced move acts as the identity on anything which is not a subset
--   of the component on which the move acted (which is the component of m.a =
--   component of m.b = component of m.c).
--   so we do stuff.

-- -- TODO think about what things we want to be proving about presolvability.
-- -- also TODO split this up into multiple functions to get shouted at less
lemma nondisconnecting_preserves_presolved {G : simple_graph V} (m : move G)
  (G_presolved : is_presolved_state G) (hm : m.resolve.reachable = G.reachable) :
  is_presolved_state m.resolve :=
begin
  intros C S S_nontrivial,

  -- TODO where are all the vertex subtypes coming from?

  -- the connected components are the same before and after
  have ccs_eq : m.resolve.connected_component = G.connected_component,
  by simp [connected_component, hm],
  -- in particular, there's one exactly corresponding to C
  let S' : G.subgraph := subgraph.of_cc (cast ccs_eq C),
  have verts_eq : S'.verts = S.verts,
  { -- FIXME this proof is some sort of crime
    ext x,
    simp only [S, S', subgraph.of_cc, subgraph.induce_verts,
      set.mem_set_of_eq, connected_component_mk, ← cast_inj ccs_eq],
    congr',
    symmetry, rw cast_eq_iff_heq,
    congr,
    exact hm },

  specialize G_presolved (cast ccs_eq C),
  dsimp only [← S'] at G_presolved,
  specialize G_presolved (by rwa verts_eq),

  split,
  { have complete_iff : ∀ {α} {A : simple_graph α}, A = ⊤ ↔ ∀ u v, u ≠ v → A.adj u v,
    { intros,
      suffices : A = ⊤ ↔ ∀ u v, A.adj u v = (⊤ : simple_graph α).adj u v,
      { simp only [this, top_adj, eq_iff_iff],
        refine (forall_congr $ λ u, forall_congr $ λ v, _),
        exact ⟨iff.mpr, λ h, ⟨ne_of_adj A, h⟩⟩ },
      refine ⟨_, ext _ _ ∘ (by simp [-top_adj]) ∘ λ h, funext (λ u, funext (h u))⟩,
      rintro rfl, simp },
    intro h_clique, apply G_presolved.1,
    rw complete_iff at ⊢ h_clique,
    contrapose! h_clique with h,
    obtain ⟨u, v, huv, h⟩ := h,

    by_cases h_cc : G.reachable u m.a,
    { use [m.a, verts_eq ▸ verts_trans_of_cc u.2 h_cc],
      use [m.b, verts_eq ▸ verts_trans_of_cc u.2 (h_cc.trans ⟨cons m.hab nil⟩)],
      split; simp [S, subgraph.of_cc] },
    use [u, verts_eq ▸ u.2, v, verts_eq ▸ v.2],
    -- NOTE there should be a subtype.coe_inj wrapper for stuff right
    split, simpa [subtype.coe_inj] using huv,
    -- TODO make this non-terminal simp go away
    simp [S, subgraph.of_cc], intros _ _,
    -- TODO rw this stuff more tersely
    rw not_or_distrib, -- not_or ?
    split,
    { apply not_and_of_not_left,
      -- TODO unfolding the definitions _and_ stuff is becoming a common pattern.
      -- do you want to perhaps have a simp lemma for the induced subgraph.of_cc
      -- stuff?
      -- TODO that simp lemma sounds like a very good idea.
      -- TODO comb through the code afterwards to check out what optimisations
      -- it introduces.
      simp only [subgraph.coe_adj, S', subgraph.of_cc, subgraph.induce_adj,
        set.mem_set_of_eq, subgraph.top_adj_iff, not_and] at h,
      exact h u.2 v.2 },

    -- u, v are in a different cc to where the move happens,
    -- we just need to prove that that means they aren't b or c.
    -- TODO think about how to do this more sanely
    have u_nr : ¬ G.reachable m.a u := λ p, h_cc p.symm,
    have v_nr : ¬ G.reachable m.a v :=
    (λ p, u_nr $ p.trans $ connected_component.exact (v.2.trans u.2.symm)),
    have b_r : G.reachable m.a m.b := ⟨cons m.hab nil⟩,
    have c_r : G.reachable m.a m.c := ⟨cons m.hac nil⟩,

    -- TODO do this in a *slightly* more sane way?
    have : ↑u ≠ m.b := λ h, absurd b_r (congr_arg (G.reachable m.a) h ▸ u_nr),
    have : ↑v ≠ m.b := λ h, absurd b_r (congr_arg (G.reachable m.a) h ▸ v_nr),
    have : ↑u ≠ m.c := λ h, absurd c_r (congr_arg (G.reachable m.a) h ▸ u_nr),
    have : ↑v ≠ m.c := λ h, absurd c_r (congr_arg (G.reachable m.a) h ▸ v_nr),
    tauto },

  -- TODO prove that restricting to a connected component preserves degree.

  obtain ⟨x, hx, h_odd⟩ := G_presolved.2,
  use [x, verts_eq ▸ hx],
  simp only [subgraph.degree, S, S', subgraph.of_cc, subgraph.neighbor_set, neighbor_set, subgraph.induce_adj] at ⊢ h_odd,
  simp only [set_of] at ⊢ h_odd,

end

-- A nontrivial forest has a node of degree 1.

-- TODO think about definitions of cycles:
-- mapping to and from stuff, blah blah, blah, blah blah blah.

-- -- TODO definition of acyclic graph, associated lemmata
--
-- lemma presolved_of_acyclic {G : simple_graph V}
--   (G_acyclic : ¬ ∃ u (p : G.walk u u), p.is_circuit) :
--   is_presolved_state G :=
-- begin
--   intros C S S_nontrivial,
--   split,
--   { contrapose! G_acyclic with S_clique,
--     -- TODO: general procedure for retrieving cycles
--     -- as embeddings from fin n. if you have graph homomorphisms
--     -- from the cycle on fin n, this probably lowers easily to an embedding.
--     have f : fin 3 ↪ S.verts :=
--     (fin.cast_le (nat.succ_le_of_lt S_nontrivial : 3 ≤ _)).to_embedding
--       .trans (fintype.equiv_fin S.verts).symm.to_embedding,
--     have f_adj : ∀ n m : fin 3, n ≠ m → G.adj (f n) (f m) := λ n m h,
--     S.adj_sub $ S_clique (by simp : f n ∈ _) (by simp : f m ∈ _) (by simpa using h),
--
--     have f_inj : ∀ {n m}, n ≠ m → (f n : V) ≠ f m :=
--     λ n m h, ne_of_adj _ (f_adj n m h),
--     -- NOTE
--     -- λ n m, not_imp_not.mpr (λ h, f.inj' (subtype.coe_inj.mp h)),
--
--     refine ⟨f 0,
--             cons (f_adj 0 1 _) $ cons (f_adj 1 2 _) $ cons (f_adj 2 0 _) nil,
--             _⟩,
--     repeat { exact fin.ne_of_vne (by simp) },
--     with_cases { refine_struct { .. } },
--     case ne_nil { simp },
--     -- simp [edges, f_inj (by simp : (0 ≠ (1 : fin 3)))],
--     -- TODO man this is bad, make it less bad.
--     -- e.g. explicitly use u, v, w instead of f stuff.
--     -- or use graph embeddings and prove a more useful general theory.
--     have : (f 0 : V) ≠ f 1 := (f_inj $ fin.ne_of_vne (by simp)),
--     have : (f 1 : V) ≠ f 2 := (f_inj $ fin.ne_of_vne (by simp)),
--     have : (f 2 : V) ≠ f 0 := (f_inj $ fin.ne_of_vne (by simp)),
--     simp [edges], tauto },
--   { -- forest has an odd degree vertex.
--     },
-- end

-- we only need the (←) direction
-- (but we can do both for fun!)
lemma imo2019q3_characterisation (G : simple_graph V) :
  exists_move_sequence_to_solved G ↔ is_presolved_state G :=
begin
  sorry
end

end lemmata

variables (n : ℕ) (G : simple_graph (fin n))

-- 1009 have 1010 neighbours, 1010 have 1009 neighbours
theorem imo2019q3 : true := ⟨⟩

end imo2019q3
